---
title: "05_PP_DGE"
author: "Ananya Gupta"
date: "2025-11-19"
output: 05_PP_DGE
---

```{r env_loading, results='FALSE',}
# Load packages, data and functions
library(Seurat)
library(tidyverse)
library(SeuratWrappers)
library(Cairo)
library(magicBatch)
library(BPCells)
library(batchelor)
library(patchwork)
library(msigdbr)
library(plotly)
library(gprofiler2)
library(hdf5r)
library(kableExtra)
library(pheatmap)
library(ggplot2)
library(gridExtra)
library(DT)
library(clustree)
library(Matrix)
library(scales)
library(data.table)
library(dplyr)
library(tidyverse)
library(glue)
library(ggrepel)
library(gprofiler2)
library(multtest)
library(scater)
library(metap)
library(future)
library(parallelly)
library(scuttle)
library(SingleCellExperiment)
library(edgeR)
library(limma)
library(EnhancedVolcano)
library(fgsea)

library(AnnotationDbi)

library(org.Mm.eg.db)
library(clusterProfiler)
plan(multicore, workers = 8)


#for parallelization
options(future.globals.maxSize = 8000 * 1024^2) 
#options(future.globals.maxSize = 1e9) was abt 1GB


# Set the random number seed
set.seed(1234)
```


```{r dir setup, include=FALSE}
base_dir <- "PP_outputs"

# Define output directories
rds_dir  <- file.path(base_dir, "PP_all_rep_rds")
fig_dir  <- file.path(base_dir, "PP_all_rep_figs")
celltype_dir <- file.path(base_dir, "PP_PCV")
dir.create(celltype_dir, showWarnings = FALSE, recursive = TRUE)


# Create folders if they don't exist
dir.create(base_dir, showWarnings = FALSE)
dir.create(rds_dir, showWarnings = FALSE)
dir.create(fig_dir, showWarnings = FALSE)
```


```{r}
#library(Cairo)
save_pub <- function(plot,
                     filename,
                     width = 7,
                     height = 7,
                     dpi = 600) {

  

  # SAVE PDF
  ggsave(
    filename = file.path(celltype_dir, paste0(filename, ".pdf")),
    plot = plot,
    device = CairoPDF,
    width = width,
    height = height,
    units = "in"
  )

  # SAVE PNG 
  CairoPNG(
    filename = file.path(celltype_dir, paste0(filename, ".png")),
    width  = width * dpi,   # convert inches → pixels
    height = height * dpi,
    res    = dpi
  )

  print(plot) 
  dev.off()

  return(plot)
}


```

```{r}
table(seu$orig.ident)
```



For differential expression analysis of a multi-sample single-cell experiment, pseudo-bulk methods outperform DE methods speciĄcally designed at the single-cell level in terms of both
stability and computational speed [14].
We explore the pseudo-bulk proĄles using a multi-dimensional scaling (MDS) plot. This visualizes the differences between the expression proĄles of different samples in two dimensions.
It can be seen that pseudo-bulk samples from the same cell cluster are close to each other.


```{r}
seu <- readRDS(file.path(rds_dir, "seu_pp_7BEC_process_04res.rds"))
```

```{r}
DefaultAssay(seu)
```


```{r}
annotations <- read.csv("PP_outputs/top20_bec04res.csv")
```

```{r}

```
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 0] <- "CapEC2"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 1] <- "Artery"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 2] <- "Mafb+ Vn"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 3] <- "TrEC"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 4] <- "PCV"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 5] <- "HEV"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 6] <- "Pre-Artery"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 7] <- "Vn Sele-"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 8] <- "Barrier EC"
seu@meta.data$cluster_annot[seu@meta.data$seurat_clusters == 9] <- "CRP"

Before doing DGE, you should aggregate (combine) the expression values of cells from the same sample and the same cell type — using either sum, mean, or a mixed-model random effect. This aggregation step is called pseudobulk, and it is necessary because cells inside the same sample are correlated (not independent).

Lets start with HEV


```{r,fig.width=10,fig.height=9}
an <- DimPlot(seu, split.by= "condition",group.by="cluster_annot",ncol=2) + ggtitle("Annotated Peyers Patches Split by Condition") +
  theme(plot.title = element_text(hjust = 0.5))
an <- LabelClusters(an, id = "cluster_annot",  fontface = "bold", size = 2.8, bg.colour = "white", bg.r = .2, force = 0)
```


```{r,fig.width=7,fig.height=5}
an <- DimPlot(seu, group.by="cluster_annot") + ggtitle("Annotated Peyers Patches") +
  theme(plot.title = element_text(hjust = 0.5))
an <- LabelClusters(an, id = "cluster_annot",  fontface = "bold", size = 2.8, bg.colour = "white", bg.r = .2, force = 0)
an
```

```{r}
save_pub(plot=an, filename="PP_all_cell_annot", width = 7, height=5)
```



```{r}
head(seu@meta.data)
```

```{r,fig.width=9, fig.height=4}
# 7 is Vn but not PCV aka 4
# Trec

DotPlot(seu, features = c("Bgn","Ctsh","Selp","B4galt6","Sele","Ackr1","Cytl1","Gucy1a1","Icam1"), group.by = "cluster_annot")
```


This is performing some dataset exploration before I form the functions


```{r}
sce <- as.SingleCellExperiment(seu, assay = "RNA")

```

```{r}
head(colData(sce))

```

```{r}
table(sce$orig.ident)
```


```{r}
set.seed(1234)  # for reproducibility

meta_df <- as.data.frame(colData(sce)) %>%
  mutate(cell = colnames(sce)) %>%
  group_by(orig.ident) %>%
  mutate(
    # shuffle cell order within each sample
    .rand = sample(seq_len(n())),
    # assign roughly equal labels 1,2,3 in random order
    pseudo_rep = rep(1:3, length.out = n())[order(.rand)]
  ) %>%
  ungroup()

# write back to SCE
colData(sce)$pseudo_rep <- meta_df$pseudo_rep[match(colnames(sce), meta_df$cell)]

```

keeping all cell types tgt just for qc

```{r}
colData(sce)$pb_id <- with(colData(sce),
                           paste(orig.ident, paste0("rep", pseudo_rep), sep = "_"))

# aggregate counts to pseudobulk level
pb_sce <- aggregateAcrossCells(
  sce,
  ids = DataFrame(
    pb_id      = sce$pb_id,
    orig.ident = sce$orig.ident,
    condition  = sce$condition,
    site       = sce$site,
    pseudo_rep = sce$pseudo_rep
  )
)

```

```{r}
pb_sce
head(colData(pb_sce))
```
```{r}
as.data.frame(colData(pb_sce)) %>%
  arrange(ncells) %>%
  select(pb_id, orig.ident, condition, pseudo_rep, ncells)

```

```{r}
# keep a copy of raw counts
assay(pb_sce, "counts_raw") <- assay(pb_sce, "counts")

# add library size
colData(pb_sce)$libsize <- colSums(assay(pb_sce, "counts_raw"))


```

```{r}

# log-normalize counts for PCA
pb_sce <- logNormCounts(pb_sce)
```

```{r}
pb_sce <- runPCA(pb_sce, exprs_values = "logcounts", ncomponents = 5)


```

```{r}
plotReducedDim(pb_sce, "PCA", colour_by = "condition")
plotReducedDim(pb_sce, "PCA", colour_by = "orig.ident")
plotReducedDim(pb_sce, "PCA", colour_by = "pseudo_rep")
plotReducedDim(pb_sce, "PCA", colour_by = "ncells")
plotReducedDim(pb_sce, "PCA", colour_by = "libsize")

```
I want to confirm if thats batch effect

```{r}
mat <- assay(pb_sce, "logcounts")
batch <- pb_sce$orig.ident

mat_corrected <- removeBatchEffect(mat, batch=batch)
pc <- prcomp(t(mat_corrected))
df <- data.frame(
  PC1 = pc$x[,1],
  PC2 = pc$x[,2],
  condition = pb_sce$condition,
  orig.ident = pb_sce$orig.ident
)

#library(ggplot2)
ggplot(df, aes(PC1, PC2, color = condition, shape = orig.ident)) +
  geom_point(size=3) +
  theme_bw()

```
```{r}
table(sce$cluster_annot, sce$condition)

```




Important to create cell type pseudobulk

```{r}
pseudobulk_celltype <- function(
  seu, 
  celltype, 
  n_pseudo = 3,
  assay_name = "RNA",
  oe_samples = c("COUPOE-PP-POS1", "COUPOE-PP1", "COUPOE-PP2"),
  seed = 1234
) {
  
  #----------------------
  # 1. Subset Seurat to that cell type
  #----------------------
  seu_sub <- subset(seu, subset = cluster_annot == celltype)
  message("Cells in this cell type: ", ncol(seu_sub))
  if (ncol(seu_sub) < 50) warning("Very few cells — PCA & DGE may be unstable.")
  
  #----------------------
  # 2. Convert to SCE
  #----------------------
  sce <- as.SingleCellExperiment(seu_sub, assay = assay_name)
  
  #----------------------
  # 3. Create pseudoreplicates per orig.ident
  #----------------------
  # set.seed(seed)
  # meta <- as.data.frame(colData(sce)) %>%
  #   mutate(cell = colnames(sce)) %>%
  #   group_by(orig.ident) %>%
  #   mutate(
  #     .rand = sample(seq_len(n())),
  #     pseudo_rep = rep(1:n_pseudo, length.out = n())[order(.rand)]
  #   ) %>%
  #   ungroup()
  #
  
  meta <- as.data.frame(colData(sce))
  meta$cell <- rownames(meta)
  
  set.seed(seed)
  
  
meta_out <- meta %>%
  group_by(orig.ident) %>%
  do({
    df <- .
    
    if (df$orig.ident[1] %in% oe_samples) {
      # Assign pseudo_rep = position in oe_samples
      rep_index <- match(df$orig.ident[1], oe_samples)
      df$pseudo_rep <- rep_index
    } else {
      # Regular random pseudoreps for WT, KO, CRE_CTRL
      df$.rand <- sample(seq_len(nrow(df)))
      df$pseudo_rep <- rep(1:n_pseudo, length.out = nrow(df))[order(df$.rand)]
    }
    
    df
  }) %>%
  ungroup()

  colData(sce)$pseudo_rep <- meta_out$pseudo_rep[match(colnames(sce), meta_out$cell)]

  
  #colData(sce)$pseudo_rep <- meta$pseudo_rep[match(colnames(sce), meta$cell)]
  
  #----------------------
  # 4. Make pseudobulk IDs
  #----------------------
  # colData(sce)$pb_id <- with(
  #   colData(sce),
  #   paste(orig.ident, paste0("rep", pseudo_rep), sep = "_")
  # )
  colData(sce)$pb_id <- ifelse(
    sce$orig.ident %in% oe_samples,
    paste0("OE_rep", sce$pseudo_rep),
    paste0(sce$orig.ident, "_rep", sce$pseudo_rep))

  #----------------------
  # 5. Aggregate to pseudobulk
  #----------------------
  pb <- aggregateAcrossCells(
    sce,
    ids = DataFrame(
      pb_id      = sce$pb_id,
      orig.ident = sce$orig.ident,
      condition  = sce$condition,
      pseudo_rep = sce$pseudo_rep
    )
  )
  colnames(pb) <- pb$pb_id

  # Save raw counts
  assay(pb, "counts_raw") <- assay(pb, "counts")
  pb$libsize <- colSums(assay(pb, "counts_raw"))
  
  #----------------------
  # 6. Normalize 
  #----------------------
  pb <- logNormCounts(pb)

  
  #----------------------
  # 8. Return everything
  #----------------------
  return(pb)
}

#use res_hev <- pseudobulk_celltype(seu, celltype = "HEV")

```

```{r}
pb_pcv <- pseudobulk_celltype(seu, celltype = "PCV")
```

```{r}
#pb_pcv
#head(colData(pb_pcv))
colnames(pb_pcv)
as.data.frame(colData(pb_pcv))[ , c("orig.ident", "condition", "pseudo_rep")]
pb_pcv$libsize

```

```{r}

#from pb make metadata,design matrix, dge list , filter, norm,disp and GLM
dge_prepare <- function(pb) {
  # library(edgeR)
  # library(dplyr)
  
  # Metadata extraction
  meta <- as.data.frame(colData(pb)) %>%
    dplyr::select(pb_id, condition, pseudo_rep)
  
  meta$condition <- factor(meta$condition)
  meta$pseudo_rep <- factor(meta$pseudo_rep)
  
  # Design matrix (no intercept)
  design <- model.matrix(~ 0 + condition + pseudo_rep , data = meta)
  
  # Build DGEList using raw pseudobulk counts
  y <- DGEList(
    counts = assay(pb, "counts_raw"),
    samples = meta
  )
  
  # Filter lowly expressed genes
  keep <- filterByExpr(y, design = design)
  y <- y[keep, , keep.lib.sizes = FALSE]
  
  # Normalize (TMM)
  y <- calcNormFactors(y)
  
  # Estimate dispersions
  y <- estimateDisp(y, design)
  
  # Fit GLM
  fit <- glmFit(y, design)
  
  # Return everything needed for contrasts
  return(list(
    fit = fit,
    design = design,
    y = y,
    meta = meta
  ))
}

```

```{r}
#pb_pcv <- pseudobulk_celltype(seu, celltype = "PCV")
pcv_dge <- dge_prepare(pb_pcv)


```

```{r}
pcv_dge$design
cbind(pcv_dge$meta$pb_id, pcv_dge$meta$condition)

```

# Differential Expression Testing
#pos fc means genes are higher in oe/ko/front neg means higher in wt 
```{r}
fit <- pcv_dge$fit
design <- pcv_dge$design

# 1. OE vs WT
c_oe_wt <- makeContrasts(conditionOE - conditionWT, levels = design)
res_oe_wt <- glmLRT(fit, contrast=c_oe_wt)
deg_oe_wt <- topTags(res_oe_wt, n = Inf)$table

# 2. KO vs WT
c_ko_wt <- makeContrasts(conditionKO - conditionWT, levels = design)
res_ko_wt <- glmLRT(fit,contrast= c_ko_wt)
deg_ko_wt <- topTags(res_ko_wt, n = Inf)$table

# 3. CRE_CTRL vs WT
c_cc_wt <- makeContrasts(conditionCRE_CTRL - conditionWT, levels = design)
res_cc_wt <- glmLRT(fit,contrast= c_cc_wt)
deg_cc_wt <- topTags(res_cc_wt, n = Inf)$table

# 4. OE vs KO
c_oe_ko <- makeContrasts(conditionOE - conditionKO, levels = design)
res_oe_ko <- glmLRT(fit,contrast= c_oe_ko)
deg_oe_ko <- topTags(res_oe_ko, n = Inf)$table
# 
# 5. WT vs CRE_CTRL
c_wt_cc <- makeContrasts(conditionWT - conditionCRE_CTRL, levels = design)
res_wt_cc <- glmLRT(fit, contrast=c_wt_cc)
deg_wt_cc <- topTags(res_wt_cc, n = Inf)$table
# 
# # 6. KO vs CRE_CTRL
# c_ko_cc <- makeContrasts(conditionKO - conditionCRE_CTRL, levels = design)
# res_ko_cc <- glmLRT(fit,contrast= c_ko_cc)
# deg_ko_cc <- topTags(res_ko_cc, n = Inf)$table


```


OE WT

log2fc = higher in oe, neg in wt, cpm is higher for more abundant gene, lr =test stat, bigger stronger evidence

```{r}
head(deg_oe_wt)
```


```{r}
# 
# write.csv(deg_oe_wt,
#           file.path(celltype_dir, "deg_oe_wt.csv"),
#           row.names = TRUE)

# How many significant genes?
sig_genes <- deg_oe_wt %>% filter(FDR < 0.05)
nrow(sig_genes)
# Output: xxx significant genes

# How many up vs down?
table(sig_genes$logFC > 0)
# FALSE (down in OE): xxx
# TRUE (up in OE): xxx
```
[1] 499

FALSE  TRUE 
  232   267 

```{r}
#ibrary(dplyr)

# Top 20 OE-upregulated genes
top_up <- deg_oe_wt %>%
  filter(FDR < 0.05, logFC > 1.2) %>%
  arrange(desc(logFC)) %>% 
  head(20)

# Top 20 WT-upregulated genes (down in OE)
top_down <- deg_oe_wt %>%
  filter(FDR < 0.05, logFC < 1.2) %>%
  arrange(logFC) %>% 
  head(20)
write.csv(top_up,
          file.path(celltype_dir, "deg_oe_wt_top20_up.csv"),
          row.names = TRUE)

write.csv(top_down,
          file.path(celltype_dir, "deg_oe_wt_top20_down.csv"),
          row.names = TRUE)

```


```{r}
# library(DT)
# 
# # Interactive searchable table
# datatable(deg_oe_wt, 
#           filter = 'top',
#           options = list(pageLength = 50))
```


Viz

```{r,fig.width=9,fig.height=7}
p <- EnhancedVolcano(
  deg_oe_wt,
  lab = rownames(deg_oe_wt),
  x = 'logFC',
  y = 'FDR',
  pCutoff = 0.05,
  FCcutoff = 1.2,     # log2 fold change cutoff of ±1
  pointSize = 2.0,
  labSize = 5,
  #col = c('grey30', 'grey30', 'royalblue', 'red2'),
  title = 'OE vs WT (PCV)',
  subtitle = 'DEG Volcano Plot',
  caption = 'Right = Upregulated | Left = Downregulated',
  legendPosition = 'right'
)
p
save_pub(plot=p,filename= "deg_oe_wt_EVplot", width = 9,height=7)
```


```{r, fig.width=9, fig.height=7}
# Genes you care about
goi <- c("Madcam1", "St6gal1",     "Nr2f2" ,"Nkx2-3", "Hey1",           "Selp", "Vcam1", "Glycam1", "Icam1")
         #addressin                 #tf                                  #general pcv/hev genes

p <- EnhancedVolcano(
  deg_oe_wt,
  lab = rownames(deg_oe_wt),
  x = 'logFC',
  y = 'FDR',
  pCutoff = 0.05,
  FCcutoff = 1.2,
  selectLab = goi,              # Only label these genes
  drawConnectors = TRUE,         # Draw lines to labels
  widthConnectors = 0.5,
  colConnectors = 'black',
  title = 'OE vs WT - Adhesion Molecules'
)

save_pub(plot=p,filename= "deg_oe_wt_goi_EVplot", width = 9,height=7)
```


```{r,fig.height=9,fig.width=11}
library(pheatmap)

# Get top 50 DEGs
top_degs <- deg_oe_wt %>%
  filter(FDR < 0.05) %>%
  arrange(FDR) %>%
  head(50)

# Extract normalized counts for these genes
library(edgeR)
norm_counts <- cpm(pcv_dge$y, log = TRUE)  # Log-CPM normalized
top_genes_mat <- norm_counts[rownames(top_degs), ]

# Create heatmap
p <- pheatmap(
  top_genes_mat,
  scale = "row",              # Z-score scaling
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  annotation_col = data.frame(
    Condition = pcv_dge$meta$condition,
    row.names = colnames(top_genes_mat)
  ),
  main = "Top 50 DEGs for PCV: OE vs WT"
)

p
save_pub(plot=p, filename ="heatmap",width = 11, height=9)
```


GO enrichment using ORA
take significant deg, convert to entrez id and check if the sig genes are over represented in GO (biological processes)

```{r}
# Significant DE genes
sig_deg <- deg_oe_wt %>% 
  filter(FDR < 0.05) 

# Up and down separately (optional)
up_deg <- sig_deg %>% filter(logFC > 0)
down_deg <- sig_deg %>% filter(logFC < 0)

# 
# library(AnnotationDbi)
# 
# library(org.Mm.eg.db)
# library(clusterProfiler)

gene_symbols <- rownames(sig_deg)

entrez_ids <- bitr(
  gene_symbols,
  fromType = "SYMBOL",
  toType = "ENTREZID",
  OrgDb = org.Mm.eg.db
)

sig_deg_entrez <- sig_deg %>% 
  mutate(SYMBOL = rownames(sig_deg)) %>%
  inner_join(entrez_ids, by = "SYMBOL")


ego_bp <- enrichGO(
  gene          = sig_deg_entrez$ENTREZID,
  OrgDb         = org.Mm.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",
  pAdjustMethod = "fdr",
  pvalueCutoff  = 0.05,
  readable      = TRUE
)

head(ego_bp)

```

```{r, fig.height=9, fig.width=14}
#this is by padj
b <- barplot(ego_bp, showCategory = 20)
d <- dotplot(ego_bp, showCategory = 20)
save_pub(plot =b, filename="barplot_GO_deg_oe_wt", width=14, height=9)
save_pub(plot =d, filename="dotplot_GO_deg_oe_wt", width=14, height=9)
```



fsgea
1.Ranks all genes by logfc more up in oe at top and most up in wt at the bottom
2. MsigBS gene set c3 is TF target geens, C2 is kegg, reactome etc
3.Filter for ets related pathways
4.NES (Normalized Enrichment Score):

Positive NES: Gene set enriched in upregulated genes (OE has more)
Negative NES: Gene set enriched in downregulated genes (WT has more)
Magnitude matters: |NES| > 2 is strong, > 1.5 is moderate


```{r}
ranks <- deg_oe_wt$logFC
names(ranks) <- rownames(deg_oe_wt)
ranks <- sort(ranks, decreasing = TRUE)
#library(msigdbr)

msig_c3 <- msigdbr(species = "Mus musculus", category = "C3") #, subcategory = "TFT")
msig_c2 <- msigdbr(species = "Mus musculus", category = "C2")


c3_tft <- split(msig_c3$gene_symbol, msig_c3$gs_name)
c2_pathways <- split(msig_c2$gene_symbol, msig_c2$gs_name)
#library(fgsea)

fgsea_ets <- fgsea(
  pathways = c3_tft,
  stats = ranks,
  minSize = 10,
  maxSize = 500
)

fgsea_ets <- fgsea_ets[grep("ETS|ERG|ELK|FLI|ETV|GGA", fgsea_ets$pathway), ]
fgsea_ets <- fgsea_ets[order(fgsea_ets$pval), ]
fgsea_ets


```


What it does: Creates dot plot of top 20 ETS-related pathways
How to interpret:

X-axis: NES (right = upregulated in OE, left = upregulated in WT)
Dot size: Significance (bigger = more significant)
Dot color: Same as NES (red = up in OE, blue = up in WT)

```{r}
#library(ggplot2)

top_ets <- fgsea_ets[order(fgsea_ets$padj), ] %>% 
  head(20)   # top 20 ETS pathways

p <- ggplot(top_ets, aes(x = NES, y = reorder(pathway, NES))) +
  geom_point(aes(size = -log10(padj), color = NES)) +
  scale_color_gradient2(low = "blue", high = "red", mid = "white") +
  labs(
    title = "ETS-related enrichment (OE vs WT)",
    x = "Normalized Enrichment Score (NES)",
    y = "ETS / ERG / ELK / ETV target sets",
    size = "-log10(FDR)"
  ) +
  theme_bw()
save_pub(plot=p,filename="ets_top20_dotplot_deg_oe_wt",width=8,height=8)
```

```{r}

```



KO WT

```{r}
# 
write.csv(deg_ko_wt,
           file.path(celltype_dir, "deg_ko_wt.csv"),
           row.names = TRUE)

# How many significant genes?
sig_genes <- deg_ko_wt %>% filter(FDR < 0.05)
nrow(sig_genes)
# Output: xxx significant genes

# How many up vs down?
table(sig_genes$logFC > 0)
# FALSE (down in OE): xxx
# TRUE (up in OE): xxx
```

[1] 1420

FALSE  TRUE 
  681   739 
  
  
```{r}
#ibrary(dplyr)

# Top 20 ko-upregulated genes
top_up <- deg_ko_wt %>%
  filter(FDR < 0.05, logFC > 1.2) %>%
  arrange(desc(logFC)) %>% 
  head(20)

# Top 20 WT-upregulated genes (down in ko)
top_down <- deg_ko_wt %>%
  filter(FDR < 0.05, logFC < 1.2) %>%
  arrange(logFC) %>% 
  head(20)
write.csv(top_up,
          file.path(celltype_dir, "deg_ko_wt_top20_up.csv"),
          row.names = TRUE)

write.csv(top_down,
          file.path(celltype_dir, "deg_ko_wt_top20_down.csv"),
          row.names = TRUE)

```

viz

```{r,fig.width=9,fig.height=7}
p <- EnhancedVolcano(
  deg_ko_wt,
  lab = rownames(deg_ko_wt),
  x = 'logFC',
  y = 'FDR',
  pCutoff = 0.05,
  FCcutoff = 1.2,     # log2 fold change cutoff of ±1
  pointSize = 2.0,
  labSize = 5,
  #col = c('grey30', 'grey30', 'royalblue', 'red2'),
  title = 'KO vs WT (PCV)',
  subtitle = 'DEG Volcano Plot',
  caption = 'Right = Upregulated | Left = Downregulated',
  legendPosition = 'right'
)
p
save_pub(plot=p,filename= "deg_ko_wt_EVplot", width = 9,height=7)
```

```{r, fig.width=9, fig.height=7}
# Genes you care about
goi <- c("Madcam1", "St6gal1",     "Nr2f2" ,"Nkx2-3", "Hey1",           "Selp", "Vcam1", "Glycam1", "Icam1")
         #addressin                 #tf                                  #general pcv/hev genes

p <- EnhancedVolcano(
  deg_ko_wt,
  lab = rownames(deg_ko_wt),
  x = 'logFC',
  y = 'FDR',
  pCutoff = 0.05,
  FCcutoff = 1.2,
  selectLab = goi,              # Only label these genes
  drawConnectors = TRUE,         # Draw lines to labels
  widthConnectors = 0.5,
  colConnectors = 'black',
  title = 'KO vs WT - Adhesion Molecules'
)

save_pub(plot=p,filename= "deg_ko_wt_goi_EVplot", width = 9,height=7)
```

```{r,fig.height=9,fig.width=11}
library(pheatmap)

# Get top 50 DEGs
top_degs <- deg_ko_wt %>%
  filter(FDR < 0.05) %>%
  arrange(FDR) %>%
  head(50)

# Extract normalized counts for these genes
#library(edgeR)
norm_counts <- cpm(pcv_dge$y, log = TRUE)  # Log-CPM normalized
top_genes_mat <- norm_counts[rownames(top_degs), ]

# Create heatmap
p <- pheatmap(
  top_genes_mat,
  scale = "row",              # Z-score scaling
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  show_rownames = TRUE,
  show_colnames = TRUE,
  annotation_col = data.frame(
    Condition = pcv_dge$meta$condition,
    row.names = colnames(top_genes_mat)
  ),
  main = "Top 50 DEGs for PCV: KO vs WT"
)

p
save_pub(plot=p, filename ="heatmap_deg_ko_wt",width = 11, height=9)
```


GO for KO vs WT


```{r}
# Significant DE genes
sig_deg <- deg_ko_wt %>% 
  filter(FDR < 0.05) 

# Up and down separately (optional)
up_deg <- sig_deg %>% filter(logFC > 0)
down_deg <- sig_deg %>% filter(logFC < 0)

# 
# library(AnnotationDbi)
# 
# library(org.Mm.eg.db)
# library(clusterProfiler)

gene_symbols <- rownames(sig_deg)

entrez_ids <- bitr(
  gene_symbols,
  fromType = "SYMBOL",
  toType = "ENTREZID",
  OrgDb = org.Mm.eg.db
)

sig_deg_entrez <- sig_deg %>% 
  mutate(SYMBOL = rownames(sig_deg)) %>%
  inner_join(entrez_ids, by = "SYMBOL")


ego_bp <- enrichGO(
  gene          = sig_deg_entrez$ENTREZID,
  OrgDb         = org.Mm.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",
  pAdjustMethod = "fdr",
  pvalueCutoff  = 0.05,
  readable      = TRUE
)

head(ego_bp)

```

```{r, fig.height=9, fig.width=14}
#this is by padj
b <- barplot(ego_bp, showCategory = 20)
d <- dotplot(ego_bp, showCategory = 20)
save_pub(plot =b, filename="barplot_GO_deg_ko_wt", width=14, height=9)
save_pub(plot =d, filename="dotplot_GO_deg_ko_wt", width=14, height=9)
```


fsgea


```{r}
ranks <- deg_ko_wt$logFC
names(ranks) <- rownames(deg_ko_wt)
ranks <- sort(ranks, decreasing = TRUE)
#library(msigdbr)

msig_c3 <- msigdbr(species = "Mus musculus", category = "C3") #, subcategory = "TFT")
msig_c2 <- msigdbr(species = "Mus musculus", category = "C2")


c3_tft <- split(msig_c3$gene_symbol, msig_c3$gs_name)
c2_pathways <- split(msig_c2$gene_symbol, msig_c2$gs_name)
#library(fgsea)

fgsea_ets <- fgsea(
  pathways = c3_tft,
  stats = ranks,
  minSize = 10,
  maxSize = 500
)

fgsea_ets <- fgsea_ets[grep("ETS|ERG|ELK|FLI|ETV|GGA", fgsea_ets$pathway), ]
fgsea_ets <- fgsea_ets[order(fgsea_ets$pval), ]
fgsea_ets


```


What it does: Creates dot plot of top 20 ETS-related pathways
How to interpret:

X-axis: NES (right = upregulated in OE, left = upregulated in WT)
Dot size: Significance (bigger = more significant)
Dot color: Same as NES (red = up in OE, blue = up in WT)

```{r}
#library(ggplot2)

top_ets <- fgsea_ets[order(fgsea_ets$padj), ] %>% 
  head(20)   # top 20 ETS pathways

p <- ggplot(top_ets, aes(x = NES, y = reorder(pathway, NES))) +
  geom_point(aes(size = -log10(padj), color = NES)) +
  scale_color_gradient2(low = "blue", high = "red", mid = "white") +
  labs(
    title = "ETS-related enrichment (KO vs WT)",
    x = "Normalized Enrichment Score (NES)",
    y = "ETS / ERG / ELK / ETV target sets",
    size = "-log10(FDR)"
  ) +
  theme_bw()
save_pub(plot=p,filename="ets_top20_dotplot_deg_ko_wt",width=8,height=8)
```









```{r}
print(msigdbr_collections(), n = Inf)

```


```{r}
# Quick check - what do the pathway names look like?
#head(names(c3_pathways), 20)
# Check if any ETS pathways exist
#grep("ERG|ETS|FLI1|GABP|ETV|ELK|SPI1", names(c3_pathways), value = TRUE, ignore.case = TRUE)
# Check what subcollections exist in C3
msigdbr_collections() %>% 
  filter(gs_collection == "C3")
```










